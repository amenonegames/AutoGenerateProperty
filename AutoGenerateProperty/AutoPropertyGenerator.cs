using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace Amenonegames.AutoProperty.Generator
{
    [Generator]
    public class AutoPropertyGenerator : ISourceGenerator
    {
        
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForPostInitialization(x => SetDefaultAttribute(x));
            context.RegisterForSyntaxNotifications( () => new SyntaxReceiver() );
        }
        
        private void SetDefaultAttribute(GeneratorPostInitializationContext context)
        {
            // AutoPropertyAttributeのコード本体
            const string AttributeText = @"
using System;
namespace AutoProperty
{
    /// <summary>
    /// This class is generated by AutoPropertyGenerator.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field,
        Inherited = false, AllowMultiple = false)]
    sealed class AutoPropAttribute : Attribute
    {
    
        public Type Type { get; set; }
        public AXS AXSType { get; set; }
        public bool GenerateInterface { get; set; }
        
        // デフォルトアクセスレベルを変える場合は、ここを変更する
        public AutoPropAttribute(AXS access = AXS.PublicGet,bool generateInterface = false)
        {
            AXSType = access;
            GenerateInterface = generateInterface;
        }

        // デフォルトアクセスレベルを変える場合は、ここを変更する
        public AutoPropAttribute(Type type, AXS access = AXS.PublicGet,bool generateInterface = false)
        {
            Type = type;
            AXSType = access;
        }

    }

    [Flags]
    internal enum AXS
    {
        PublicGet = 1,
        PublicGetSet = 1 << 1,
        PublicGetPrivateSet = 1 << 2,
        PrivateGet = 1 << 3,
        PrivateGetSet = 1 << 4,
        ProtectedGet = 1 << 5,
        ProtectedGetSet = 1 << 6,
        ProtectedGetPrivateSet = 1 << 7,
        InternalGet = 1 << 8,
        InternalGetSet = 1 << 9,
        InternalGetPrivateSet = 1 << 10,
        ProtectedInternalGet = 1 << 11,
        ProtectedInternalGetSet = 1 << 12,
        ProtectedInternalGetPrivateSet = 1 << 13,
    }
}
";            
            //コンパイル時に参照するアセンブリを追加
            context.AddSource
            (
                "AutoPropAttribute.cs",
                SourceText.From(AttributeText,Encoding.UTF8)
            );
        }
        
        public struct SymbolsInVariable
        {
            public IFieldSymbol field;
            public ITypeSymbol sourceType;
            public ITypeSymbol targetType;
            public bool generateInterface;
            public AXS acess;

            public SymbolsInVariable(IFieldSymbol field , ITypeSymbol sourceType, ITypeSymbol targetType, bool generateInterface, AXS acess)
            {
                this.field = field;
                this.sourceType = sourceType;
                this.targetType = targetType;
                this.generateInterface = generateInterface;
                this.acess = acess;
            }
                
        }
        

        public void Execute(GeneratorExecutionContext context)
        {
            //Context.SyntaxReceiverというプロパティに格納されているので
            //それを取得する
            var receiver = context.SyntaxReceiver as SyntaxReceiver;
            if (receiver == null) return;
            
            var fieldSymbols = new List<SymbolsInVariable>();

            foreach (var field in receiver.TargetFields)
            {
                var model = context.Compilation.GetSemanticModel(field.field.SyntaxTree);
                foreach (var variable in field.field.Declaration.Variables)
                {
                    var fieldSymbol = ModelExtensions.GetDeclaredSymbol(model, variable) as IFieldSymbol;

                    var arguments = field.attr.ArgumentList?.Arguments;
                    
                    var sourceType = fieldSymbol.Type;
                    var targetType = fieldSymbol.Type;
                    var generateInterface = false;
                    var acess = AXS.PublicGet;
                    
                    // (IFieldSymbol field, ITypeSymbol sourceType , ITypeSymbol targetType , AXS acess) result =
                    //     (fieldSymbol, fieldSymbol.Type, fieldSymbol.Type, AXS.PublicGet); // デフォルトアクセスレベルを変える場合は、ここを変更する
                    if (arguments.HasValue)
                    {
                        
                        foreach (var argument in arguments)
                        {
                            var expr = argument.Expression;
                            var type = ModelExtensions.GetTypeInfo(model, expr).Type;
                            if ( expr is TypeOfExpressionSyntax typeOfExpr)
                            {
                                var typeSymbol = ModelExtensions.GetSymbolInfo(model, typeOfExpr.Type).Symbol as ITypeSymbol;
                                targetType = typeSymbol;
                            }
                            else if (type != null && type.SpecialType == SpecialType.System_Boolean)
                            {
                                if (expr is LiteralExpressionSyntax literalExpression)
                                {
                                    if (literalExpression.IsKind(SyntaxKind.TrueLiteralExpression))
                                    {
                                        generateInterface = true;
                                    }
                                    else if (literalExpression.IsKind(SyntaxKind.FalseLiteralExpression))
                                    {
                                        generateInterface = false;
                                    }
                                }
                            }
                            else
                            {
                                var parsed = Enum.ToObject(typeof(AXS), model.GetConstantValue(expr).Value);
                                acess = (AXS)parsed;
                            }
           
                        }
                    }
                    fieldSymbols.Add(new SymbolsInVariable (fieldSymbol,sourceType,targetType,generateInterface,acess));
                }
            }
            
            //クラス単位にまとめて、そこからpartialなクラスを生成したいので、
            //クラス名をキーにしてグループ化する
            foreach (var group in fieldSymbols.GroupBy(field=>field.field.ContainingType))
            {
                //classSourceにクラス定義のコードが入る
                var classSource = ProcessClass(group.Key, group.ToArray());
                //クラス名.Generated.csという名前でコード生成
                context.AddSource
                    (
                        $"{group.Key.Name}.Generated.cs",
                        SourceText.From(classSource,Encoding.UTF8)
                    );

            }
            
        }
        
        private string ProcessClass(INamedTypeSymbol classSymbol, SymbolsInVariable[] fieldSymbols)
        {
            
            var interfaceRequireVariable = fieldSymbols.Where(x=>x.generateInterface
                                                                 && (x.acess == AXS.PublicGet || x.acess == AXS.PublicGetPrivateSet ||x.acess == AXS.PublicGetSet )).ToArray();
            
            var classAccessiblity = classSymbol.DeclaredAccessibility.ToString().ToLower();
            var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace ? "" : $"namespace {classSymbol.ContainingNamespace.ToDisplayString()}\n{{\n";
            var classDeclaration = $@"
    // This class is generated by AutoPropertyGenerator.
    {classAccessiblity} partial class {classSymbol.Name}";
            
            var builder = new StringBuilder();
            builder.Append(namespaceName);
            builder.Append(classDeclaration);
            
            if(interfaceRequireVariable.Length > 0)
                builder.Append($@": I{classSymbol.Name}");
            
            builder.Append(@"
    {"); // Open class

            foreach (SymbolsInVariable data in fieldSymbols)
            {
                var className = data.targetType.ToDisplayString();
                var sourceClassName = data.sourceType.ToDisplayString();
                var propertyName = GetPropertyName(data.field.Name);
                bool typeIsSame = className == sourceClassName;

                switch (data.acess)
                {
                    case AXS.PrivateGet:
                    case AXS.PrivateGetSet:
                        builder.Append($@"
        private {className} {propertyName}
        {{
            get
            {{");
                        break;
                    case AXS.PublicGet:
                    case AXS.PublicGetSet:
                    case AXS.PublicGetPrivateSet:
                        builder.Append($@"
        public {className} {propertyName}
        {{
            get
            {{");
                        break;
                    case AXS.ProtectedGet:
                    case AXS.ProtectedGetSet:
                    case AXS.ProtectedGetPrivateSet:
                        builder.Append($@"
        protected {className} {propertyName}
        {{
            get
            {{");
                        break;
                    case AXS.InternalGet:
                    case AXS.InternalGetSet:
                    case AXS.InternalGetPrivateSet:
                        builder.Append($@"
        internal {className} {propertyName}
        {{
            get
            {{");
                        break;
                    case AXS.ProtectedInternalGet:
                    case AXS.ProtectedInternalGetSet:
                    case AXS.ProtectedInternalGetPrivateSet:
                        builder.Append($@"
        protected internal {className} {propertyName}
        {{
            get
            {{");
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                
                if (typeIsSame)
                {
                        builder.Append($@"
                return this.{data.field.Name};
            }}");
                }
                else
                {
                    builder.Append($@"
            return ({className})this.{data.field.Name};
            }}");
                }
                

                switch (data.acess)
                {
                    case AXS.PrivateGetSet:
                    case AXS.ProtectedGetSet:
                    case AXS.PublicGetSet:
                    case AXS.InternalGetSet:
                    case AXS.ProtectedInternalGetSet:
                        builder.Append($@"
            set
            {{");
                        if (typeIsSame)
                        {
                        builder.Append($@"
                this.{data.field.Name} = value;
            }}");
                        }
                        else
                        {
                        builder.Append($@"
                this.{data.field.Name} = ({sourceClassName})value;
            }}");
                        }

                    break;
                        
                    case AXS.PublicGetPrivateSet:
                    case AXS.ProtectedGetPrivateSet:
                    case AXS.InternalGetPrivateSet:
                    case AXS.ProtectedInternalGetPrivateSet:
                        builder.Append($@"
            private set
            {{");
                        if (typeIsSame)
                        {
                            builder.Append($@"
                this.{data.field.Name} = value;
            }}");
                        }
                        else
                        {
                            builder.Append($@"
                this.{data.field.Name} = ({sourceClassName})value;
            }}");
                        }
                        
                        break;
                    

                }

                    builder.Append($@"
        }}
");
            }
            

            builder.Append(@"
    }"); // Close class
            

            if (interfaceRequireVariable.Length > 0)
            {
                builder.Append($@"
    // This interface is generated by AutoPropertyGenerator.
    {classAccessiblity} partial interface I{classSymbol.Name}
    {{");
                foreach (var data in interfaceRequireVariable)
                {
                    var className = data.targetType.ToDisplayString();
                    var propertyName = GetPropertyName(data.field.Name);

                    switch (data.acess)
                    { 
                        case AXS.PublicGet:
                        case AXS.PublicGetPrivateSet:
                            builder.Append($@"
        public {className} {propertyName}
        {{get;}}");
                            break;
                        case AXS.PublicGetSet:
                            builder.Append($@"
        public {className} {propertyName}
        {{get;set;}}");
                            break;
                        
                        default:
                            throw new ArgumentOutOfRangeException();
                    }

                }
                builder.Append(@"
    }"); // Close interface
            }

            if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                builder.Append(@"
}"); // Close namespace
            }

            return builder.ToString();
        }

        
        private string GetPropertyName(string fieldName)
        {
            
            // 最初の大文字に変換可能な文字を探す
            for (int i = 0; i < fieldName.Length; i++)
            {
                if (char.IsLower(fieldName[i]))
                {
                    // 大文字に変換して、残りの文字列を結合
                    return char.ToUpper(fieldName[i]) + fieldName.Substring(i + 1);
                }
            }

            // 大文字に変換可能な文字がない場合
            return "NoLetterCanUppercase";
        }
        
        private (bool Implicit ,bool Explicit) CheckConversionInType(ITypeSymbol typeToCheck, ITypeSymbol targetType)
        {
            (bool Implicit ,bool Explicit) result = (false ,false);
                    
            foreach (var member in typeToCheck.GetMembers())
            {
                if (member is IMethodSymbol methodSymbol &&
                    methodSymbol.MethodKind == MethodKind.Conversion &&
                    methodSymbol.ReturnType.Equals(targetType, SymbolEqualityComparer.Default))
                {
                    if(methodSymbol.IsImplicitlyDeclared)
                        result.Implicit = true;
                    else
                        result.Explicit = true;
                }
            }
            
            return result;
        }
        
        

    }

    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<(FieldDeclarationSyntax field, AttributeSyntax attr)> TargetFields { get; } = new List<(FieldDeclarationSyntax field, AttributeSyntax attr)>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is FieldDeclarationSyntax field)
            {
                foreach (var attributeList in field.AttributeLists)
                {
                    foreach (var attribute in attributeList.Attributes)
                    {
                        // ここで属性の名前をチェックします
                        if (attribute.Name.ToString().EndsWith("AutoPropAttribute") ||
                            attribute.Name.ToString().EndsWith("AutoProp")) // 短縮形も考慮
                        {
                            TargetFields.Add((field,attribute));
                            return; // 一致する属性が見つかったら、他の属性はチェックしない
                        }
                    }
                }
            }
        }
    }
    
    
}